{"meta":{"title":"韩涛的个人主页","subtitle":null,"description":null,"author":"Han Tao","url":"https://ishantao.github.io"},"pages":[{"title":"","date":"2018-08-29T13:36:08.900Z","updated":"2018-08-29T13:36:08.900Z","comments":true,"path":"tags/index.html","permalink":"https://ishantao.github.io/tags/index.html","excerpt":"","text":"title: 标签date: 日期type: “tags”comments: false"},{"title":"","date":"2018-08-29T13:35:21.682Z","updated":"2018-08-29T13:35:21.682Z","comments":true,"path":"categories/index.html","permalink":"https://ishantao.github.io/categories/index.html","excerpt":"","text":"title: 分类date: 日期type: “categories”comments: false"},{"title":"简介","date":"2018-08-30T11:54:39.000Z","updated":"2018-09-03T06:25:25.850Z","comments":true,"path":"about/index.html","permalink":"https://ishantao.github.io/about/index.html","excerpt":"","text":"#个人简介 ##编程小萌新 ##大佬带带我"}],"posts":[{"title":"Python 面向对象","slug":"Python-面向对象","date":"2018-10-29T06:42:28.000Z","updated":"2018-11-02T00:55:07.523Z","comments":true,"path":"2018/10/29/Python-面向对象/","link":"","permalink":"https://ishantao.github.io/2018/10/29/Python-面向对象/","excerpt":"","text":"Python 面向对象面向对象技术简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 创建类使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾: 123class ClassName: '类的帮助信息' #类文档字符串 class_suite #类体 类的帮助信息可以通过ClassName.__doc__查看。 class_suite 由类成员，方法，数据属性组成。 实例以下是一个简单的 Python 类的例子: 实例1234567891011121314class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print \"Total Employee %d\" % Employee.empCount def displayEmployee(self): print \"Name : \", self.name, \", Salary: \", self.salary empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。 第一种方法init()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。 self代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: 1234567class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test()t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x10d066878&gt;__main__.Test 创建实例对象实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。 以下使用类的名称 Employee 来实例化，并通过 init 方法接收参数。 1234&quot;创建 Employee 类的第一个对象&quot;emp1 = Employee(&quot;Zara&quot;, 2000)&quot;创建 Employee 类的第二个对象&quot;emp2 = Employee(&quot;Manni&quot;, 5000) 访问属性您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量: 123emp1.displayEmployee()emp2.displayEmployee()print &quot;Total Employee %d&quot; % Employee.empCount 你也可以使用以下函数的方式来访问属性： getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 python对象销毁(垃圾回收)Python 使用了引用计数这一简单技术来跟踪和回收垃圾。 在 Python 内部记录着所有使用中的对象各有多少引用。 一个内部跟踪变量，称为一个引用计数器。 当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。 1234567a = 40 # 创建对象 &lt;40&gt;b = a # 增加引用， &lt;40&gt; 的计数c = [b] # 增加引用. &lt;40&gt; 的计数del a # 减少引用 &lt;40&gt; 的计数b = 100 # 减少引用 &lt;40&gt; 的计数c[0] = -1 # 减少引用 &lt;40&gt; 的计数 垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。 实例析构函数 _del__ ，__del__在对象销毁的时候被调用，当对象不再被使用时，\\_del__方法运行： 123456789101112131415class Point: def __init__( self, x=0, y=0): self.x = x self.y = y def __del__(self): class_name = self.__class__.__name__ print class_name, \"销毁\" pt1 = Point()pt2 = pt1pt3 = pt1print id(pt1), id(pt2), id(pt3) # 打印对象的iddel pt1del pt2del pt3 以上实例运行结果如下： 123083401324 3083401324 3083401324Point 销毁 类的继承面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 继承语法 12class 派生类名(基类名) ... 在python中继承中的一些特点： 1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。 2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数 3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。 语法： 派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示： 12class SubClassName (ParentClass1[, ParentClass2, ...]): ... 1234567891011121314151617181920212223242526class Parent: # 定义父类 parentAttr = 100 def __init__(self): print \"调用父类构造函数\" def parentMethod(self): print '调用父类方法' def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print \"父类属性 :\", Parent.parentAttr class Child(Parent): # 定义子类 def __init__(self): print \"调用子类构造方法\" def childMethod(self): print '调用子类方法' c = Child() # 实例化子类c.childMethod() # 调用子类的方法c.parentMethod() # 调用父类方法c.setAttr(200) # 再次调用父类的方法 - 设置属性值c.getAttr() # 再次调用父类的方法 - 获取属性值 以上代码执行结果如下： 1234调用子类构造方法调用子类方法调用父类方法父类属性 : 200 你可以继承多个类 12345678class A: # 定义类 A.....class B: # 定义类 B.....class C(A, B): # 继承类 A 和 B..... 你可以使用issubclass()或者isinstance()方法来检测。 issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup) isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法： 实例： 12345678910class Parent: # 定义父类 def myMethod(self): print '调用父类方法' class Child(Parent): # 定义子类 def myMethod(self): print '调用子类方法' c = Child() # 子类实例c.myMethod() # 子类调用重写方法 基础重载方法下表列出了一些通用的功能，你可以在自己的类重写： 序号 方法, 描述 &amp; 简单的调用 1 init ( self [,args…] ) 构造函数 简单的调用方法: obj = className(args) 2 del( self ) 析构方法, 删除一个对象 简单的调用方法 : del obj 3 repr( self ) 转化为供解释器读取的形式 简单的调用方法 : repr(obj) 4 str( self ) 用于将值转化为适于人阅读的形式 简单的调用方法 : str(obj) 5 cmp ( self, x ) 对象比较 简单的调用方法 : cmp(obj, x) 运算符重载Python同样支持运算符重载，实例如下： 1234567891011121314class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print v1 + v2 以上代码执行结果如下所示: 1Vector(7,8) 类属性与方法类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods 1234567891011121314class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print self.__secretCount counter = JustCounter()counter.count()counter.count()print counter.publicCountprint counter.__secretCount # 报错，实例不能访问私有变量 Python不允许实例化的类访问私有数据，但你可以使用 object.className__attrName（ **对象名.类名__私有属性名** ）访问属性，参考以下实例： 12345678#!/usr/bin/python# -*- coding: UTF-8 -*-class Runoob: __site = \"www.runoob.com\"runoob = Runoob()print runoob._Runoob__site 执行以上代码，执行结果如下： 1www.runoob.com 单下划线、双下划线、头尾双下划线说明： foo: 定义的是特殊方法，一般是系统定义名字 ，类似 init() 之类的。 _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://ishantao.github.io/tags/Python/"}]},{"title":"Python DB Mysql","slug":"Python-DB-Mysql","date":"2018-10-26T01:22:32.000Z","updated":"2018-10-29T01:47:19.656Z","comments":true,"path":"2018/10/26/Python-DB-Mysql/","link":"","permalink":"https://ishantao.github.io/2018/10/26/Python-DB-Mysql/","excerpt":"","text":"数据库连接实例：以下实例链接 Mysql 的 TESTDB 数据库： 1234567891011121314151617181920 import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"root\",\"123456\",\"python_db\" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute(\"SELECT VERSION()\") # 使用 fetchone() 方法获取单条数据.data = cursor.fetchone() print (\"Database version : %s \" % data) # 关闭数据库连接db.close() 执行以上脚本输出结果如下： 1Database version : 5.5.20-log 创建数据库表如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表EMPLOYEE： 12345678910111213141516171819202122232425 import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"testuser\",\"test123\",\"TESTDB\" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL，如果表存在则删除cursor.execute(\"DROP TABLE IF EXISTS EMPLOYEE\") # 使用预处理语句创建表sql = \"\"\"CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )\"\"\" cursor.execute(sql) # 关闭数据库连接db.close() 数据库插入操作以下实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录： 123456789101112131415161718192021222324import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"testuser\",\"test123\",\"TESTDB\" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句sql = \"\"\"INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES ('Mac', 'Mohan', 20, 'M', 2000)\"\"\"try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 如果发生错误则回滚 db.rollback() # 关闭数据库连接db.close() 以上例子也可以写成如下形式： 123456789101112131415161718192021222324import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"testuser\",\"test123\",\"TESTDB\" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句sql = \"INSERT INTO EMPLOYEE(FIRST_NAME, \\ LAST_NAME, AGE, SEX, INCOME) \\ VALUES ('%s', '%s', '%d', '%c', '%d' )\" % \\ ('Mac', 'Mohan', 20, 'M', 2000)try: # 执行sql语句 cursor.execute(sql) # 执行sql语句 db.commit()except: # 发生错误时回滚 db.rollback() # 关闭数据库连接db.close() 以下代码使用变量向SQL语句中传递参数: 1234567..................................user_id = \"test123\"password = \"password\"con.execute('insert into Login values(\"%s\", \"%s\")' % \\ (user_id, password)).................................. 数据库查询操作Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象 fetchall(): 接收全部的返回结果行. rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。 实例：查询EMPLOYEE表中salary（工资）字段大于1000的所有数据： 123456789101112131415161718192021222324252627282930import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"testuser\",\"test123\",\"TESTDB\" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 查询语句sql = \"SELECT * FROM EMPLOYEE \\ WHERE INCOME &gt; '%d'\" % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print (\"fname=%s,lname=%s,age=%d,sex=%s,income=%d\" % \\ (fname, lname, age, sex, income ))except: print (\"Error: unable to fetch data\") # 关闭数据库连接db.close() 以上脚本执行结果如下： 1fname=Mac, lname=Mohan, age=20, sex=M, income=2000 数据库更新操作更新操作用于更新数据表的的数据，以下实例将 TESTDB 表中 SEX 为 ‘M’ 的 AGE 字段递增 1： 123456789101112131415161718192021import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"testuser\",\"test123\",\"TESTDB\" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 更新语句sql = \"UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'\" % ('M')try: # 执行SQL语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback() # 关闭数据库连接db.close() 删除操作删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据： 123456789101112131415161718192021import pymysql # 打开数据库连接db = pymysql.connect(\"localhost\",\"testuser\",\"test123\",\"TESTDB\" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 删除语句sql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; '%d'\" % (20)try: # 执行SQL语句 cursor.execute(sql) # 提交修改 db.commit()except: # 发生错误时回滚 db.rollback() # 关闭连接db.close() 执行事务事务机制可以确保数据一致性。 事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。 实例12345678910# SQL删除记录语句sql = \"DELETE FROM EMPLOYEE WHERE AGE &gt; '%d'\" % (20)try: # 执行SQL语句 cursor.execute(sql) # 向数据库提交 db.commit()except: # 发生错误时回滚 db.rollback() # SQL删除记录语句 sql = “DELETE FROM EMPLOYEE WHERE AGE &gt; ‘%d’” % (20) try: # 执行SQL语句 cursor.execute(sql) # 向数据库提交 db.commit() except: # 发生错误时回滚 db.rollback() 对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。 commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。 错误处理DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常: 异常 描述 Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。 Error 警告以外所有其他错误类。必须是 StandardError 的子类。 InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。 DatabaseError 和数据库有关的错误发生时触发。 必须是Error的子类。 DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。 OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。 IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。 InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。 ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。 NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://ishantao.github.io/tags/Python/"}]},{"title":"正则","slug":"正则","date":"2018-10-23T08:18:46.000Z","updated":"2018-10-23T09:00:04.232Z","comments":true,"path":"2018/10/23/正则/","link":"","permalink":"https://ishantao.github.io/2018/10/23/正则/","excerpt":"","text":"正则表达式正则的简介​ 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 \\\\。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。 { 标记限定符表达式的开始。要匹配 {，请使用\\ {。 \\ 指明两项之间的一个选择。要匹配 \\ ，请使用 \\ 。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。","categories":[],"tags":[]},{"title":"关于Servlet的参数接收","slug":"关于Servlet的参数接收","date":"2018-10-23T02:27:59.000Z","updated":"2018-10-23T08:07:27.112Z","comments":true,"path":"2018/10/23/关于Servlet的参数接收/","link":"","permalink":"https://ishantao.github.io/2018/10/23/关于Servlet的参数接收/","excerpt":"","text":"servlet servlet的简介​ Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。 ​ 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 servlet的创建1234567891011121314151617181920212223242526272829package com.ht.servlt;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Project: ServletStu * @Package: $&#123;PACKAGE_NAME&#125; * @Author: 韩涛 * @Date: 2018-10-23 15:12 * @Description: * @Param: **/@WebServlet(name = \"Test0Servlet\",urlPatterns = \"/test0\")public class Test0Servlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; servlet的使用1//访问http://localhost:8080/test0 servlet中参数接收1. get请求​ get请求只有请求头没得请求body,所以只能在头中携带参数,而且有长度限制 123456789101112131415161718@WebServlet(name = \"TestServlet\", urlPatterns = \"/test\")public class TestServlet extends HttpServlet &#123;@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements())&#123; String s = headerNames.nextElement(); System.out.println(s + \": \" + request.getHeader(s)); &#125;//遍历请求头信息,就看一下 String res = request.getParameter(\"haha\");//获取参数名为\"haha\"的参数 response.setContentType(\"test/html;charset=utf-8\"); PrintWriter writer = response.getWriter(); writer.write(res.toString()); //向客户端返回参数的值 System.out.println(res); System.out.println(\"doGet\"); &#125;&#125; 1//访问http://localhost:8080/test?haha=1234后返回1234 2. 非get请求​ 非get请求中有请求body可以携带更多的参数,文件等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.ht.servlt;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;import java.io.*;import java.util.Collection;import java.util.Iterator;@MultipartConfig@WebServlet(name = \"UploadTestServlet\",urlPatterns = &#123;\"/upload\"&#125;)public class Test2servlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Collection&lt;Part&gt; parts = request.getParts(); Iterator&lt;Part&gt; iterator = parts.iterator(); while (iterator.hasNext())&#123; Part next = iterator.next(); if (next.getContentType() != null)&#123; System.out.println(next.getName()+\" ContentType: \" +next.getContentType()); saveFile(next); &#125;else &#123; System.out.println(next.getName()+\" ContentType: \" +next.getContentType()); String value = getParameterByName(next); System.out.println(next.getName() + \": \" + value); &#125; &#125; &#125; private void saveFile(Part next) &#123; File file = new File(\"D:\\\\\" + next.getSubmittedFileName()); try &#123; next.write(file.getAbsolutePath()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private String getParameterByName(Part next) &#123; String value = \"\"; try &#123; InputStream inputStream = next.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer sbuffer = new StringBuffer(); String s = \"\"; while ((s = bufferedReader.readLine())!=null)&#123; sbuffer.append(s); &#125; value = new String(sbuffer.toString().getBytes(),\"utf-8\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return value; &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125;//解析form表单//保存文件到本地 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.ht.servlt;import com.google.gson.Gson;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Project: ServletStu * @Package: $&#123;PACKAGE_NAME&#125; * @Author: 韩涛 * @Date: 2018-10-23 14:25 * @Description: * @Param: **/@WebServlet(name = \"Test3Servlet\", urlPatterns = \"/test3\")public class Test3Servlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); response.setContentType(\"test/html;charset=utf-8\"); String contentType = request.getContentType(); ServletInputStream ris = request.getInputStream(); StringBuilder content = new StringBuilder(); byte[] b = new byte[1024]; int lens = -1; while ((lens = ris.read(b)) &gt; 0) &#123; content.append(new String(b, 0, lens,\"utf-8\")); &#125; String strcont = content.toString(); System.out.println(contentType+\": \" +strcont); //通过流获取流中的json字符串 Gson gson = new Gson(); PeopleBean peopleBean = gson.fromJson(strcont,PeopleBean.class); System.out.println(peopleBean.getId()); System.out.println(\"解析结果: \"+peopleBean); //通过json解析得到的字符串 &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125;//解析json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ht.servlt;/** * @Project: ServletStu * @Package: com.ht.servlt * @Author: 韩涛 * @Date: 2018-10-23 14:39 * @Description: * @Param: **/public class PeopleBean &#123; String name; String Id; String sex; String qqNumber; @Override public String toString() &#123; return \"PeopleBean&#123;\" + \"name='\" + name + '\\'' + \", Id='\" + Id + '\\'' + \", sex='\" + sex + '\\'' + \", qqNumber='\" + qqNumber + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return Id; &#125; public void setId(String id) &#123; Id = id; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getQqNumber() &#123; return qqNumber; &#125; public void setQqNumber(String qqNumber) &#123; this.qqNumber = qqNumber; &#125;&#125;//实体类","categories":[],"tags":[{"name":"servlet","slug":"servlet","permalink":"https://ishantao.github.io/tags/servlet/"}]},{"title":"Redis","slug":"Redis","date":"2018-10-10T06:35:59.000Z","updated":"2018-10-10T08:28:04.837Z","comments":true,"path":"2018/10/10/Redis/","link":"","permalink":"https://ishantao.github.io/2018/10/10/Redis/","excerpt":"","text":"Redis学习 Redis简介​ Redis 是基于内存的数据库，并且提供一定的持久化功能，他是一种键值（key-value）数据库，使用key作为索引找到当前的缓冲数据，并且返回给调用者。 Redis在Java中的简单使用123456789101112131415161718192021222324252627@Test public void test()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //连接最大空闲数 poolConfig.setMaxIdle(50); //最大的连接数 poolConfig.setMaxTotal(100); //最大等待毫秒数 poolConfig.setMaxWaitMillis(20000); JedisPool pool = new JedisPool(poolConfig,\"localhost\",6379); //从连接池中获取单个连接 Jedis jedis = pool.getResource(); //如果需要密码 //jedis.auth(\"password\") int i = 0; long start = System.currentTimeMillis(); while (true)&#123; long end = System.currentTimeMillis(); if(end-start &gt;= 1000)&#123; break; &#125; i++; jedis.set(\"test\"+i, i + \"\"); &#125; jedis.close(); System.out.println(\"do \" + i+\" times\"); &#125; Redis 在spring中的使用1. spring-data-redis 注意版本问题，版本很容易出问题123456789101112&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 配置JedisPollConfig对象12345&lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"50\"&gt;&lt;/property&gt; &lt;property name=\"maxWaitMillis\" value=\"20000\"&gt;&lt;/property&gt; &lt;property name=\"maxTotal\" value=\"100\"&gt;&lt;/property&gt;&lt;/bean&gt; 3. 配置JedisConnectionFactory123456&lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"localhost\"&gt;&lt;/property&gt; &lt;property name=\"port\" value=\"6379\"&gt;&lt;/property&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--password 可以配置密码--&gt; 4. 配置spring RedisTemplate1234567&lt;bean id=\"jdkSerializationRedisSerializer\" class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"&gt;&lt;/bean&gt;&lt;bean id=\"stringRedisSerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt;&lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"&gt;&lt;/property&gt; &lt;property name=\"keySerializer\" ref=\"stringRedisSerializer\"&gt;&lt;/property&gt; &lt;property name=\"valueSerializer\" ref=\"jdkSerializationRedisSerializer\"&gt;&lt;/property&gt;&lt;/bean&gt; 5. 可以使用了1234567@Test public void test2()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring/spring-redis.xml\"); //字符串是配置文件的位置 RedisTemplate redisTemplate = applicationContext.getBean(RedisTemplate.class); System.out.println(redisTemplate.opsForValue().get(\"key\")); &#125; Redis的数据类型及其操作String​ String 是Redis的最基本的数据结构，它将一个键和值储存与redis的内部，象java的Map结构，让Redis通过键去找值 ​ 基本命令 命令 说明 备注 set key value 设置键值对 常用写入命令 get key 通过键获取值 常用读取命令 del key 通过键，删除键值对 通用命令在其他数据类型中也有该命令，返回删除数 strlen key 获取key指向字符串长度 返回长度 getset key value 修改key对应的值并返回旧值 如原值为空则返回空，设新值 getrange key start end 获取字串 将字符串看成数组返回start-end之间的字符串 append key value 键value添加到key对应的值中 返回新字符串的长度 ​ 简单运算 命令 说明 备注 incr key 在原字段上+1 只能说整数 incrby key value 在原字段上+value 只能是整数 decr key 在原字段上-1 只能是整数 decrby key value 在云字段上-value 只能是整数 incrbyfloat value 在原字段上加浮点数 可以是浮点数或者整数 ·","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://ishantao.github.io/tags/Redis/"}]},{"title":"JS_DOM操作","slug":"JS-DOM操作","date":"2018-09-05T00:27:54.000Z","updated":"2018-09-05T12:52:41.019Z","comments":true,"path":"2018/09/05/JS-DOM操作/","link":"","permalink":"https://ishantao.github.io/2018/09/05/JS-DOM操作/","excerpt":"","text":"JavaScript DOM 操作DOM 查找 基本查找document.getElementById() ​ 返回指定ID的元素。只有一个对象。 ​ 说明： 如果没有指定ID的元素返回null; ​ 如果存在多个指定ID的元素则返回undefined; ​ 浏览器支持情况：所有浏览器都支持。 document.getElementsByName() ​ 返回带有指定name的对象的集合。是一个对象的集合。 ​ 浏览器支持情况：所有浏览器都支持。 document.getElementsByTagName() ​ 返回带有指定标签名的集合。是一个对象的集合。 ​ 浏览器支持情况：所有浏览器都支持。 document.getElementsByClassName() ​ 返回带有指定类名的集合。是一个对象的集合。 ​ 有些低版本的浏览器不支持 遍历节点树 parentNode //父级元素，顶级父级元素为document； childNodes //子节点们 : firstChild //第一个子节点 lastChild //最后一个子节点 nextSibling //后一个兄弟节点 previousSiling //前一个兄弟节点 找到的节点都包含，空格，换行和注释； 不包括空格，换行和注释。 children //会找到所有子节点不包括空格和回车和注释 1234567891011121314151617&lt;div id=\"div0\"&gt; &lt;div id=\"divB\"&gt; &lt;div id=\"divA\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"divC\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var div0 = document.getElementById(\"div0\"); console.log(div0); console.log(div0.children); console.log(div0.children.length); console.log(div0.firstChild); &lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485HTMLCollection(2) [div#divB, div#divC, divB: div#divB, divC: div#divC]0:div#divB1:div#divClength:2divB:div#divBdivC:div#divC__proto__:HTMLCollectionindex.html:23 2index.html:24 #textassignedSlot:nullbaseURI:\"file:///C:/Users/Administrator/Desktop/index.html\"childNodes:NodeList []data:\"↵ \"firstChild:nullisConnected:truelastChild:nulllength:3nextElementSibling:div#divBnextSibling:div#divBnodeName:\"#text\"nodeType:3nodeValue:\"↵ \"ownerDocument:documentparentElement:div#div0parentNode:div#div0previousElementSibling:nullpreviousSibling:nulltextContent:\"↵ \"wholeText:\"↵ \"__proto__:Text 补充在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： 1. nodeName : 节点的名称 2. nodeValue ：节点的值 3. nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 二、nodeValue 属性：节点的值 \\1. 元素节点的 nodeValue 是 undefined 或 null \\2. 文本节点的 nodeValue 是文本自身 \\3. 属性节点的 nodeValue 是属性的值 三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 DOM为元素设置属性​ 语法：Element.styleName.property=”styleValue”。 ​ 功能： 设置Element的css样式 ​ 说明： 1. Element为DOM的对象。不能是getElements...返回的数组，必须进行遍历访问每个元素 2. styleName为设置样式的名字：如：font，height。 3. styleValue为设置样式的值：如：style.color = &quot;#f00&quot;; innerHTML和className操作**语法：**Element.innerHTMl ​ 功能： 返回element元素开始和结束标签之间的HTML和文本 ​ 语法： element.innerHTMl = “html” ​ 功能: 设置element元素开始和结束标签之间的HTML内容为html 1234567891011&lt;div id=\"div1\"&gt; &lt;li&gt;haha&lt;/li&gt; &lt;li&gt;&lt;i&gt;hehe&lt;/i&gt;&lt;/li&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div0 = document.getElementById(\"div1\").getElementsByTagName(\"li\"); for (var i = 0; i &lt; div0.length; i++) &#123; console.log(div0[i]innerHTML) &#125; &lt;/script&gt; ​ 获取的innerHTML 12haha&lt;i&gt;hehe&lt;/i&gt; ​ 语法： element.className ​ 功能： 返回element的class属性 ​ 语法： element.className = “cls” ​ 功能：设置element的class属性为cls 会清楚掉以前的类 12345678910&lt;div id=\"div1\"&gt; &lt;li class = \"class1\"&gt;haha&lt;/li&gt; &lt;li class = \"class1\"&gt;&lt;i&gt;hehe&lt;/i&gt;&lt;/li&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div0 = document.getElementById(\"div1\").getElementsByTagName(\"li\"); for (var i = 0; i &lt; div0.length; i++) &#123; console.log(div0[i].className) &#125;&lt;/script&gt; 输出 12class1class2 DOM属性的获取与设置​ 语法： element.getAttribute(“name”); ​ 获取一些自定义的属性。自带属性除class外都可以通过”.属性”获取 12","categories":[{"name":"-学习","slug":"学习","permalink":"https://ishantao.github.io/categories/学习/"}],"tags":[{"name":"-Javascript","slug":"Javascript","permalink":"https://ishantao.github.io/tags/Javascript/"}]},{"title":"Javascript简单语法","slug":"JavaScript","date":"2018-09-03T11:54:39.000Z","updated":"2018-09-04T11:41:43.908Z","comments":true,"path":"2018/09/03/JavaScript/","link":"","permalink":"https://ishantao.github.io/2018/09/03/JavaScript/","excerpt":"","text":"JavaScript 的基本语法数据类型 1. 区分大小写 2. 命名规范： 1. 由字母，数字，下划线（_）组成或者是（$）符号 2. 不能以数字开头 3. 不能够使用关键字，保留字等作为标识符 3. 变量是**松散类型** 可以用来保存任何类型的数据 123456var name_01;//合法var 8_name; //不合法var age = 18;var email = \"123456789@qq.ocm\";var name_02 = \"haha\", age_1 = 18, email_1 = \"321654@qq.com\";// 1. 省略var声明的变量是全局变量 （不推荐使用） 基本数据类型 Undefined ：未定义类型 Null ：null值表示一个空对象指针，如果定义的变量在将来保存对象，最好初始化为努null。undefined是null派生的所以null == undefined为true。 Boolean ： 123//数字除0之外转化成布尔都是true//字符串除空串之外转化成布尔都是true//null和undefined转成布尔为false number ：表示整数或浮点数，NaN（Not a Number）表示非数值，属于Number。涉及NaN的操作（如：NaN/10）都会返回NaN，NaN与任何数值都不相等，包括本身。 12 String : 字符串。 123//toString()与String()str.toString() //str是要转换的类容，可以是数值，布尔，对象和字符串String（）//是一个函数可以将任何类型转化成字符串，类似与Number（）； 复杂数据类型 Object 12345//typeof的使用返回变量的类型var name_1 = \"Mary\"；typeof name_1;typeof(name_20);//两种都可以 数值转换1234567var age = \"16\";Number（age）//返回为值16,类型是numbervar topval = \"28px\";parseInt(topval)；//返回为28，类型是number，但是只能是数字开头才能提取到数字var num = \"12.34.56\"parseFloat（num）;//知道第一个小数点，后返回为12.34parseFloat（\"000.12\"）//忽略前导0，返回0.12 操作符 算术操作符 +，-，*，/，% ，++a（先增加在用），a++（先用在增加） 1234var a = 10;var b = 5;var c = a++-b //c的值为5，a的值为11var d = ++a-b//c的值为6，a的值为11 逻辑操作符 ： ! , ||, &amp;&amp; 123//! 首先把数据转化为布尔值，然后取反，结果为true或false// 逻辑与 &amp;&amp; js中逻辑与和其他语言不太一样，如果第一个操作数是true(或者能够转为true)，计算结果就是第二个操作数，如果第一个操作数是false，结果就是false（短路计算），对于一些特殊数值不遵循以上规则.//逻辑或 || 如果第一个操作数不是false，结果就是第一个操作数，否则结果是第二个操作数。如果第一个操作数能够转为true，结果就是第一个操作数 赋值操作符 ：=, +=,-=,/=,*= 12var a = 5;a = a + 5;//==&gt;a +=5; 比较操作符 ：&lt;,&gt; ,&lt;=,==,===,!=,!==返回值boolean 12//==值是否相等//===全等还要比较类型. 三元操作符 ： ? 可以代替简单的if语句 12var age = 18;var result = (age&gt;18)?\"成年\":\"不成年\"； if语句1234567891011121314151617181920//第一种var age = 18;if(age&gt;18)&#123; alert(\"你以成年\")；&#125;else&#123; alert(\"你还未成年\");&#125;//第二种var age = 18if(age &lt; 18)&#123; alert(\"你还未成年\");&#125;else if(age &gt;= 18 &amp;&amp; age &lt;= 59)&#123; aleart(\"你可以进入\");&#125;else&#123; alert(\"你以超出年纪\");&#125;//if语句可以没有else块//可以嵌套使用。 switch 语句1234567891011121314151617181920212223var day = new Date().getDay();switch (day)&#123; case 0: alert(\"星期日\"); break; case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; default: alert(\"星期六\");&#125; 循环语句123456789101112131415var sum = 0;for(var i = 1; i &lt; 10; i++)&#123; sum +=i; &#125;//sum结果为45；var sum = 0;var i = 0;while(i &lt; 10)&#123; sum += i; i++;&#125;//sum值为45；//break跳出循环//跳出本次循环 function123456789101112131415161718function myFunction()&#123; alert(\"我是函数\"); &#125;function myFunction1(num1,num2)&#123; var sum = mun1 + num2; alert(sum);&#125;//参数不需要指定参数类型function test()&#123; //arguments 传进来的所有参数，可以跟数组一样的访问 arguments.length //参数的个数 arguments[0] //第一个参数&#125;test（1,1,3,5,6）;//arguments.length==5//arguments[0]==1 Array(数组) 对象创建方法1var people = [\"people1\", \"people2\"]; 123var people = new Array();people[0] = \"haha\";people[1] = \"hehe\"; 1var people = new Array(\"people\",\"people1\"); 访问：与Java相同根据下标访问与Java不同点 在一个数组中可以有多种类型的变量 可以包含一些对象元素，函数，数组 常用方法增,删12345678910//push把值加在数组最后var people = new Array();people.push(\"Mary\");//unshift把值加在数组前头people.unshift(\"Bob\");//pop删掉最后一个var n = pople.pop();// n = \"Mary\" ,people 中只有\"Bob\";//shift删掉第一个与pop类似people。shift(); 转成String12345678//join()方法，将数组转成stringvar num = [0,1,2];var str = num.join();//srt 是\"0,1,2\"var str1 = num.jion(\"\");//str1是\"012\"var str2 = num.join(\"-\");//str2 是\"0-1-2\"; 查找123456indexOf(a,b)//从b开始查找a出现的位置，没找到返回值为-1.a元素要与数组中元素的类型一至才能找到。lastIndexOf(\".\")从末尾开始。var arr = [\"1\",\"1\",\"2\",\"1\",\"3\"];var pos = arr.indexOf(\"1\",2);var pos1 = arr.indexOf(1,2);alert(pos);//pos的值为3alert(pos1);//pos1的值为-1 其他常用方法12345678910111213141516171819reverse();//将数组反转sort(function(a,b)&#123; return b-a;&#125;); //对数组进行降序排列//sort（）将数字会转化成string进行排列，所以要给他一个函数作为比较方法。concat()//将多个数组连接起来slice(a,b)//从a开始截取到b。a可以是负数，若是负数从数组尾部开始,b若不写则截取到结尾。var arr = [\"1\",\"2\",\"3\"];var arr1 = arr.slice(-2,3) //==&gt;arr.slice(1,3);//splice(a,b)从a开始删除b个元素，反回值为删除的数组元素。b为0则不删除。//splice(a,0,\"m\",\"n\")在a的后面插入\"m\",\"n\".返回值为空//splice()还可以用于替换。var arr = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"];arr.splice(0,2);//从0开始删除两个元素arr.splice(0,0,\"a\",\"b\");//从0开始添加\"a\",\"b\"arr.splice(0,1,\"x\")//从0开始删除一个元素，在从0开始添加一个\"x\". 实例12345678//实例：获取文件后缀名var url = \"abcd.hh.txt\";function getFileFormat(url)&#123; var pos = url.lastIndexOf(\".\"); return url.substr(pos);&#125;var format = getFileFormat(url); JavaScript 中的对象JavaScript 中一切都为对象：​ 字符串，数组，数字，函数和自定义对象 JavaScript对象1. JavaScript提供了多个内建对象如string，data，array等。 2. 对象只是带有属性和方法的特殊数据类型 访问对象的属性与方法​ 与Java相同classname.name可以访问 访问属性例如： 1objectName.propertyName 访问方法例如： 12var message=\"Hello world!\";var x=message.toUpperCase(); 创建对象的方法 定义并创建对象的实例 使用函数来定义对象，然后创建新的对象实例 实例： 12345678910111213141516171819202122232425//第一种创建了对象的一个新实例，并向其添加了四个属性：person=new Object();person.firstname=\"Bill\";person.lastname=\"Gates\";person.age=56;person.eyecolor=\"blue\";//替代语法（使用对象 literals）属于第一种方法person=&#123;firstname:\"John\",lastname:\"Doe\",age:50,eyecolor:\"blue\"&#125;;//第二种使用对象构造器function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; function changeName(name)&#123; this.lastname=name; &#125;&#125;//实例化var myFather=new person(\"Bill\",\"Gates\",56,\"blue\");var myMother=new person(\"Steve\",\"Jobs\",48,\"green\");myMother.changeName(\"Ballmer\"); JavaScript 类1. JavaScript 是面向对象的语言，但 JavaScript 不使用类。 2. 在 JavaScript 中，不会创建类，也不会通过类来创建对（就像在其他面向对象的语言中那样）。JavaScript 基于 prototype，而不是基于类的。 JavaScript for..in 循环12345678var person=&#123;fname:\"Bill\",lname:\"Gates\",age:56&#125;;for (x in person) &#123; txt=txt + person[x]; &#125;//txt = BillGates56; 常用的一些函数获取星期几12new Date().getDay();//返回值number（0-6）,0是星期日 输出1document.write(\"你好\");","categories":[{"name":"-学习","slug":"学习","permalink":"https://ishantao.github.io/categories/学习/"}],"tags":[{"name":"-JavaScript","slug":"JavaScript","permalink":"https://ishantao.github.io/tags/JavaScript/"}]},{"title":"Ajax和Json","slug":"Ajax和Json","date":"2018-08-30T11:54:39.000Z","updated":"2018-09-03T12:27:24.283Z","comments":true,"path":"2018/08/30/Ajax和Json/","link":"","permalink":"https://ishantao.github.io/2018/08/30/Ajax和Json/","excerpt":"","text":"Ajax和JsonAjax### Ajax是什么 1. AJAX = 异步 JavaScript 和 XML。 2. AJAX 是一种用于创建快速动态网页的技术。 3. 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 4. 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 5. **AJAX应用程序与浏览器和平台无关的！** jQuery对Ajax的使用​ 实例： 123456789$.ajax(&#123; url: \"/edit/topic/upload\", data: data, type: \"post\", dataType: \"json\", success: function (data) &#123; alert(data.message); &#125; &#125;) 常用参数说明： url：要求为String类型的参数，（默认为当前页地址）发送请求的地址 ，可以是jsp也可以是controller层的地址。 type ：要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 cache ：要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 data ：要求为Object或String类型的参数，发送到服务器的数据。如果不是字符串，将自动转换为字符串格式。get请求中将附加在url后。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 dataType :要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下： xml：返回XML文档，可用JQuery处理。 html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。 script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。 json：返回JSON数据。 jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。 text：返回纯文本字符串。 success :要求为Function类型的参数，请求成功后调用的回调函数。可以携带后台传回的数据。 1234567891011//获取后台传来的json数据并在标签中填入success:function (data) &#123; $(\"#e_id\").val(data.id); $(\"#e_name\").val(data.name); $(\"#e_classId\").val(data.classId); $(\"#e_qqNumber\").val(data.qqNumber); $(\"#e_roomId\").val(data.roomId); $(\"#e_sex\").val(data.sex);&#125; 使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;form class=\"form-group\" id=\"topic\"&gt; &lt;div class=\"container col-md-6\" style=\"float:left\"&gt; &lt;textarea class=\"form-control\" rows=\"10\" name=\"content\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"container col-md-6\" style=\"float: right\"&gt; &lt;div class=\"md-2 \"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"answerNumber\" value=\"1\"&gt; &lt;/label&gt; A: &lt;input type=\"text\" class=\"form-control\" name=\"answer\"&gt; &lt;/div&gt; &lt;div class=\"md-2\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"answerNumber\" value=\"2\"&gt; &lt;/label&gt; B: &lt;input id=\"radio\" type=\"text\" class=\"form-control\" name=\"answer\"&gt; &lt;/div&gt; &lt;div class=\"md-2\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"answerNumber\" value=\"3\"&gt; &lt;/label&gt; C：&lt;input type=\"text\" class=\"form-control\" name=\"answer\"&gt; &lt;/div&gt; &lt;div class=\"md-2\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"answerNumber\" value=\"4\"&gt; &lt;/label&gt; D：&lt;input type=\"text\" class=\"form-control\" name=\"answer\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;//前台name属性与后台属性一一对应，若有多个name重名，那么会将其组成一个数组，一起传给后台。$(\"#submitBtn\").click(function () &#123; var data = $(\"#topic\").serialize();//将表格的数据序列化 alert(data); $.ajax(&#123; url: \"/edit/topic/upload\", data: data, type: \"s\", dataType: \"json\", success: function (data) &#123; alert(data.message); &#125; &#125;) &#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041@ResponseBody @RequestMapping(value = \"/upload\",method = RequestMethod.POST) public Msg receiveTopic(Topic topic , HttpSession session) throws Exception &#123; //实体类topic中，有与前台name属性对应的字段，会将其自动赋予topic属性中。 Msg msg = new Msg();//Msg 是自定义的一个消息类用于前后台数据交互。 log.debug(\"提示+++++++++\"+topic); msg.setStatus(ResultEnum.SUCCESS.value()); if (checkAnswer(topic.getAnswerNumber())||StringUtils.isEmpty(topic.getContent())) &#123; msg.setMessage(\"题目上传失败，请检查题目格式\"); return msg; &#125; else &#123; int teacherId = 1; int subjectId = 1; log.debug(\"提示:----------- :\" + topic + \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); topic.setStatus(0); topic.setSubjectId(subjectId); topic.setTeacherId(teacherId); String answer = topic.getAnswer(); if (!StringUtils.isEmpty(answer)) &#123; String[] answers = answer.split(\",\"); if(answers.length&lt;4)&#123; msg.setMessage(\"题目上传失败，请检查题目格式\"); return msg; &#125; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; answers.length - 1; i++) &#123; stringBuffer.append(answers[i] + \"-\"); &#125; stringBuffer.append(answers[answers.length - 1]); topic.setAnswer(stringBuffer.toString()); &#125; else &#123; topic.setAnswer(\"chose\"); &#125; msg.setMessage(\"上传成功\"); uploadTopicService.uploadTopic(topic); return msg; &#125; &#125;","categories":[{"name":"-学习","slug":"学习","permalink":"https://ishantao.github.io/categories/学习/"}],"tags":[{"name":"-JSON -Ajax","slug":"JSON-Ajax","permalink":"https://ishantao.github.io/tags/JSON-Ajax/"}]},{"title":"First","slug":"hantao","date":"2018-08-29T12:45:43.218Z","updated":"2018-08-30T00:45:13.802Z","comments":true,"path":"2018/08/29/hantao/","link":"","permalink":"https://ishantao.github.io/2018/08/29/hantao/","excerpt":"","text":"我的弟一片文章哈哈终于成功了1String = \"终于成功了\";","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-08-29T11:18:45.646Z","updated":"2018-08-29T11:18:45.647Z","comments":true,"path":"2018/08/29/hello-world/","link":"","permalink":"https://ishantao.github.io/2018/08/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}